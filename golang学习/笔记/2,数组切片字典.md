# 一、数组

https://www.liwenzhou.com/posts/Go/05_array/

## 1，数组的声明

```go
var a [3]int64
var b [2]bool
var c [10]string
```

**注意事项**

1. 数组的长度必须是常量，并且长度是数组类型的一部分.
2. 数组支持索引访问 `a[1]` 、`c[7]`，索引的合法范围：`0`~`len(array)-1`，**不支持负数索引**。
2. 未初始化的数组 == nil



## 2，数组初始化

```go
var x = [3]int{1, 2, 3}
var y = [...]bool{true, false, true}  // r
var z = [100]int{99:1}
var zz = [...]int{99:1}
```

## 3，数组的遍历

```go
const ind = 10
var arr6 = [...]string{1: "周公瑾", 3: "关云长", ind: "诸葛亮"}

fmt.Println("for遍历")
for i := 0; i < len(arr6); i++ {
    fmt.Println(arr6[i])
}

fmt.Println("for range 遍历")
for index, val := range arr6 {
    fmt.Println(index, val)
}
```



## 4，多维数据

这里以二维数组为例，三维数组、四维数组类似。

二维数组的定义

```go
var xx = [3][2]string{
		{"北京", "石家庄"},
		{"上海", "苏州"},
		{"成都", "重庆"}, // 注意：最外层的花括号换行则这里必须加,
	}
```



二维数组的遍历

索引遍历

```go
for i := 0; i < len(xx); i++ {
		tmp := xx[i]
		// 第一层
		fmt.Printf("xx[%v]:%v\n", i, xx[i])
		// 第二层
		for j := 0; j < len(tmp); j++ {
			fmt.Printf("\t xx[%v][%v]:%v\n", i, j, tmp[j])
		}
	}
```



for range遍历

```go
for i1, v1 := range xx {
		fmt.Printf("xx[%v]: %v\n", i1, v1)
		// 第二层
		for i2, v2 := range v1 {
			fmt.Printf("\txx[%v][%v]:%v\n", i1, i2, v2)
		}
	}
```



## 5，数组是值类型

**赋值、函数传参都是深度拷贝，修改副本不影响原值。**

![image-20220109123320558](E:\home\golang学习\笔记\数组切片字典.assets\image-20220109123320558.png)

**Go语言中全部都是值拷贝（深拷贝），Go语言是通过传递指针实现修改原来的值。**（后面讲指针细说）

# 二、切片

https://www.liwenzhou.com/posts/Go/06_slice/

## 1，切片声明

```go
var s []int  // nil
```

## 2，切片的原理

大力出奇迹教育公司的例子



## 3，切片表达式

切片表达式中的数字都是指的 **索引** ！！！

### 切片简短表达式

对字符串和数组：`0 <= low < high <= len`

对切片：`0 <= low < high <= cap`

### 切片完整表达式

```go
func slice3() {
	// 默认切片的容量是从切片的开始索引到数组的最后
	// max: 影响切片的容量
	// max:想象成high能取到的最大值
	// 最终切片的容量：max-low
	a := []int{1, 2, 3, 4, 5}
	// a[low:high:max]
	s1 := a[1:2:3]                    // 0 <= low <= high <= max <= cap(a)
	fmt.Println(s1, len(s1), cap(s1)) // [2] 2 2
}
```

### 字面量初始化

```go
// 字面量初始化(花括号)
func slice4() {
	s1 := []int{1, 2, 3}
	fmt.Println(s1)  // [1 2 3]
	s2 := []int{99: 1}
	fmt.Println(s2)
}
```

## 4，make初始化切片

切片声明之后需要使用内置的make函数做初始化！

```go
// 使用make函数初始化
	// make([]T, len, cap) cap可以省略,cap=len
	// s = make([]int, 2) // len = cap = 2
	// s = make([]int, 2, 4) // len = cap = 2
	s = make([]int, 2, 4)          // len =2, cap = 4
	fmt.Println(s, len(s), cap(s)) // [0 0] 2 4
	fmt.Println(s == nil)          // false

	s1 := make([]int, 0)
	fmt.Println(s1 == nil) // false

	s2 := make([]int, 0, 15)          // 一次把内存申请到位
	fmt.Println(s2, len(s2), cap(s2)) // ?

	// 如果你确定一个切片中最终要存储的元素个数，那么你最好一次把内存申请到位
```



### 切片的复制

切片的赋值时浅拷贝，会修改原来的值！！！！

所以建议使用内置函数进行切片的拷贝

```go
func copyDemo2() {
	a := []int{1, 2, 3}
	// var b = make([]int, 0, len(a))
	b := make([]int, len(a)) // 直接按目标切片的长度进行初始化
	copy(b, a)               // 把切片a中的值拷贝到切片b中
	fmt.Println(b)           // ?
	b[1] = 200

	fmt.Println(a) // ?
	fmt.Println(b) // [1 200 3]
}
```

**使用copy函数要注意，事先初始化好切片的长度**

```go
func copyDemo() {
	a := []int{1, 2, 3}
	// var b = make([]int, 0, len(a))
	b := make([]int, 0)  //！！！！！！！！  错误
     b := make([]int, 10)   // 初始化的切片长度要大于被拷贝的切片的长度
	copy(b, a)     // 把切片a中的值拷贝到切片b中
	fmt.Println(b) // ? 为什么？
}
```



## 5，append函数

**使用append函数时必须接收返回值！！！**

```go
func appendDemo() {
	var s = []string{"北京"}
	// apend函数可能触发切片的扩容
	// 切片扩容之后会有一个新的底层数组，需要更新变量s
	s = append(s, "上海")
	fmt.Println(s) // [北京 上海]

	s2 := []string{"广州", "深圳"}
	s = append(s, s2...) // ...表示将s2拆开一个一个元素追加
	fmt.Println(s)       // [北京 上海 广州 深圳]

	// 零值切片可以直接在append中使用
	var s3 []int // nil
	fmt.Println(s3 == nil)
	s3 = append(s3, 1)
	s3 = append(s3, 2, 3, 4)
	fmt.Println(s3)
}
```



### append触发扩容

```go
// go源码--扩容C:\Program Files\Go\src\runtime\slice.go  growslice

// appendDemo2 使用append函数触发扩容
// 导致意想不到的事情发生
func appendDemo2() {
	var s = []string{"北京"}
	_ = append(s, "上海", "广州", "深圳")
	fmt.Println(s) // [北京]
}

// appendDemo3 append函数导致切片扩容示例
func appendDemo3() {
	var s = []string{"北京"}
	fmt.Println(len(s), cap(s)) // len = cap = 1
	s = append(s, "上海", "广州", "深圳")
	fmt.Println(len(s), cap(s)) // 4 4
	fmt.Println(s)              // [北京]
}
```

## 6，删除切片的元素

```go
// deleteSlice 删除切片中的元素
func deleteSlice(idx int) {
	idx = 1
	var s = []int{1, 2, 3}
	s = append(s[:idx], s[idx+1:]...)
	fmt.Println(s)
}
```



### 切片操作技巧（补充）

https://www.liwenzhou.com/posts/Go/slice_tricks/



# 三、map（字典）



## 1，map函数的原理 

map是key-value结构的数据类型，类似于其他语言中的hash table,dict等

key必须是可hash的值，是一个确定的值（key的值不能设置了之后又发生了改变）

map存储的时候 hash(key) --> 固定的值  --> 把value放到对应的位置保存

map[key]  : hash(key) --> 得到值 --> 取对应的value



## 2，map初始化

```go
func mapDemo1() {
	var m map[string]int

	fmt.Println(m == nil)    // true
	m = make(map[string]int) // 只要初始化就可以赋值
	fmt.Println(m == nil)    // false

	m["jade"] = 300 // 设置值
	fmt.Println(m)
	weight := m["jade"] // 取值
	fmt.Println(weight)

	// 字面量初始化
	m2 := map[string]string{
		"username": "七米",
		"password": "1234", // 花括号换行则此处必须加逗号
	}
	fmt.Printf("%#v\n", m2)

	name := m2["name"]
	fmt.Println(name)
	// v, ok 取值  ; ok是一个变量名，只不过大家约定成俗在这里用ok
	// ok = true表示map中有这个key， ok=false表示map没有这个key
	// 如果没有这个key，此时v=对应类型的零值
	v, ok := m2["name"] // 类似与for range 可以用一个变量也可以两个变量接收
	fmt.Println(v, ok)

	_, ok = m2["name"]
	fmt.Println(ok)
}
```

## 3，map遍历

```go
// map的遍历（map是无序的）
func mapDemo2() {
	m := map[string]int{
		"jade": 300,
		"ddd":  180,
		"嚯嚯嚯":  160,
	}

	for k, v := range m {
		fmt.Println(k, v)
	}

	// 只取map中的key
	for k := range m {
		fmt.Println(k)
	}

	// 只取map中的value
	for _, v := range m {
		fmt.Println(v)
	}

}
```

## 4，从map中删除键值对

```go
// 从map中删除键值对
delete(m, "jade") // 没有返回值
fmt.Println(m)
```

## 5，判断key是否存在

```go
// 判断map中是否存在某个key
_, ok := m["小盆子"]
fmt.Println(ok)
```

## 6，map+slice 组成复杂一点的数据类型

```go
// 元素类型是map的切片
func sliceMapDemo1() {
	// []int []string []map[string]int
	var mapSlice = make([]map[string]string, 3)

	for index, value := range mapSlice {
		fmt.Printf("index:%d value:%v\n", index, value)
	}
	fmt.Println("after init")
	// 对切片中的map元素进行初始化
	mapSlice[0] = make(map[string]string, 10)
	mapSlice[0]["name"] = "小王子"
	mapSlice[0]["password"] = "123456"
	mapSlice[0]["address"] = "沙河"
	for index, value := range mapSlice {
		fmt.Printf("index:%d value:%v\n", index, value)
	}
}

func mapSliceDemo2() {
	// map[string]int  map[string][]int
	var sliceMap = make(map[string][]string, 3)

	fmt.Println(sliceMap)
	fmt.Println("after init")
	key := "中国"
	value, ok := sliceMap[key]
	if !ok {
		value = make([]string, 0, 2)
	}
	value = append(value, "北京", "上海")
	sliceMap[key] = value
	fmt.Println(sliceMap)
}
```





































