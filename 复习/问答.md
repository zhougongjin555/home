# **Python****相关**

### 熟悉Python编程语言，能够熟练编写python脚本并拥有良好的代码习惯。

```
迭代器：同时拥有__iter__& __next__两个方法
可迭代对象：拥有__iter__方法，并且返回迭代器对象
s
```



### 研究Python C 底层源码了解内存管理、GC垃圾回收机制。

```
	python创建的所有对象都会存放在一个refchain双向环状链表里面，并且在对象存放的时候，除了数据的封装之外（单个元素只保存值，多个元素组成还会保存元素个数,c内部是pyvarobject结构体），还会额外的保存上一个对象，下一个对象，类型，以及引用个数（C语言封装成为一个pyobject结构体）
	引用计数器被引用的时候，值会+1，，删除引用，会-1，当引用计数器为0，代表没人使用了，此时会将此对象进行垃圾回收（从链表移除，并删除）
	但是，循环引用时候(a=[1,2] b=[3,4] a.append(b) b.append(a)),此时a,b的引用计数器都为2，del a,b之后只对引用-1，并未完全删除。
	所以，标记清除来解决这个问题，python底层再次维护一个链表（存放可能循环引用的对象————内部可以放其他对象的对象），python在特定条件下会扫描这个链表，如果油循环引用，会对引用计数器再次-1
	那么触发条件是什么呢？以及如何解决每次扫描耗时较多的问题呢？
	此时，python又有一个分代回收机制，首先，将新的链表分解成为三个链表，称为0代，1代，2代，（默认0代，扫描后，0代垃圾被回收，未被回收的放1代，类推）扫描条件：
	0：对象达到700，扫描
	1：0代扫描10次，扫描
	2：1代扫描10次，扫描
	
额外：
小数据池-5~257，只开辟一次内存，自动创建，不销毁
free_list:部分应该被回收的对象没回收，而是放到内存的一个free_List中（有个数限制），当创建新对象，不新开辟空间，而是直接找free_list上一个对象，直接修改他的值。
```



### 研究网络协议，以及网络编程的阻塞，非阻塞，IO多路复用实现原理

```
https://www.cnblogs.com/clschao/articles/9713797.html
http协议规定了数据传输的格式，基于tcp，短链接无状态
请求行+ 请求头+ 空行+ 请求数据
相应行+ 响应头+ 空行+ 响应数据
三握：
	客户端请求链接会发送SYN包封装一个数据x给服务段
	服务端收到包会将值ack=x+1,并在封装一个y给syn包一并返回
	客户端会校验收到的ack值，同时再次发送ack=y+1给服务端
四挥：
	客户端请求关闭链接发送FIN值并封装数据x给服务器
	服务端收到数据x,ack=x+1返回，然后进入等待状态
	服务端事务处理完成后，再次发送一个FIN封装数据y
	客户端收到FIN，会ack=y+1返回

osi7: pleae do not tell stupid prople anything
physical 物理
data_link 数据链路
network 网络
transport 传输
session 会话
presentation 表示
application 应用

tcp:安全性高，慢，粘
udp:不安全，块，不粘
粘包：1，客户端发送数据小，导致在自己缓冲区粘了（无解）
	2，客户端发送的快，导致服务端粘了（加数据大小字段）


	在网络通讯过程中，一旦发生数据交互的行为，一般都会涉及到两个阶段，首先是数据准备阶段（wait data），其次是数据从内核拷贝到进程阶段(copy data)
	阻塞io，接收端发送一个system call向内核询问数据，然后一直阻塞住，直到有数据传输过来，然后拷贝数据，完成数据接收。
	非阻塞io，接收端不会阻塞在等待数据阶段（没有数据，会接收到内核返回的错误信息，捕获即可），会一直询问知道数据准备完成，然后拷贝数据，done
	io多路复用，不再监听单一链接，而是利用select模块同时监听多个链接(一次向系统请求所有链接的状态)，代替执行等待数据过程（wait data），一旦有链接数据准备完成，可以直接拷贝数据(copy data)，done

额外：
	select:  唯一win能用，又最大监听数量限制1024
	poll:  linux可用，无最大数量限制
	epoll:  解决poll轮询查看状态消耗大的问题，不再主动轮询，而是给每一个连接绑定回调事件，当有新连接时候，主动去接受数据
	
	
```



### 熟悉进程，线程，协程概念，以及使用python实现并发编程。

![image-20211212211619140](E:\home\复习\assets\QQ截图20211212212730.png)

![image-20211212211619140](E:\home\复习\assets\QQ图片20211212211535.png)

```
	进程是资源分配的最小单位，线程是CPu调度的最小单位，每个进程里面至少一个线程，进程中所有线程资源共享。协程是目的基于单线程实现并发
	GIL锁，同一时刻一个进程里面只有一个线程能够被调用

	进程池传输数据一定要用Manager().Queue(),别用原生的queue()
	
    无论是进程还是线程，都遵循：守护xxx会等待主xxx运行完毕后被销毁 
    需要强调的是：运行完毕并非终止运行

    1.对主进程来说，运行完毕指的是主进程代码运行完毕 
    2.对主线程来说，运行完毕指的是主线程所在的进程内所有非守护线程统统运行完毕，主线程才算运行完毕
	守护进程：主进程代码执行完成，所有进程结束
	守护线程：所有非守护线程执行完毕，守护线程结束
	
	
	锁：互斥锁-锁一次解一次，如果再锁，就是死锁
		递归锁-多次使用，可以必变死锁
	进程通讯：队列，管道，文件
```

```python
# 进程，进程池，常见方法展示

from multiprocessing import Process

def task(a, b):
    pass

if __name__ == '__main__':	
    a = Process(target=task, args=(1,2,)) # 函数加入进程
    a.daemon = True    # 守护进程
    a.start()    # 开始进程
    a.join()     # 阻塞进程



from concurrent.futures import ThreadPoolExecutor,ProcessPoolExecutor

process_pool = ProcessPoolExecutor(10)    # 创建包含十个进程的进程池

def task_2(a, b):
    pass
def callback(res):   # 参数一定要带，默认传送进程对象
    pass


for i in range(10):
    a = process_pool.submit(task_2, (i, 1))  # 将进程加入到进程池
    print(a.result())    # 拿到执行完成后返回的结果
    a.add_done_callback(callback)  # 此处会默认传送进程对象，不需要手动传送
process_pool.shutdown()   # 阻塞，等待线程池所有的线程执行完成，在继续往下执行

```



### 熟悉Python Django框架，以及其中的Middleware、ORM、ModelForm等组件。

```
django:mtv mvc
url控制器+view视图层+模板曾+models模型层
url：
	分发-统一类型url放到另一个组里面，include()
	反向解析-自动拼接url
	名称空间-指明url所属app，include(,namespace='')
view:
	存放函数，根据url返回对应页面
	request对象 + render，redirect，HTTPresponse
models:
	存放数据表，charfield、bollenfield...
	null-表数据可空,blank-页面填写验证可空
	
	建完单表book，开始增删改查操作
	增：
		book.objects.create()
		book.objects.bulk_create()
		book.objects.create_or_update()、get_or_create
	删：
		book.objects.filter().delete()
	改：
		book.objects.filter().update()
	查：
		.all .first...普查
		aggregate聚合查，annotate分组查
		extra原生sql查结果做条件
		raw原生sql查
		__lt,__gt,__in...模糊查
		F查（支持加减）Q查（支持w运算）
	
	多表查询
	OneToOneField 一对一
	ForeignKey	 一对多，在多
	ManyToManyField 多对多
	
	字段在那个表那个是正，
	一多，多多，正向字段，反向表小_set
	一一，正向字段，反向表小
	双下划线，正向.values('表明__字段')
			反向表小
			
			
中间件：
process_request			请求处理
process_response		响应处理
process_view		    视图函数之前
process_exception		出错执行

form表单+模板	字段校验，渲染，钩子。。。
session&cookie http无状态，不保存信息cookie保存在客户端，有限制，session保存在服务端，无限制，更灵活
ajax... 


```



### 熟悉Restful规范，熟悉django rest framework框架以及前后端分离开发。

```
restful规范：
1，使用https规范，接口更安全（数据非明文）
2，api接口要在url中体现api标识（https://api.gongjin.com）
3，api接口要体现版本信息（https://api.gongjin.com/v1/）
4，对同一资源不同请求方式实现不同的操作，并返回不同数据
	get-查  post-插 put-全更新 patch-部分更新 delete-删
5，url传递搜索条件（https://api.gongjin.com/v1/a=1?b=2）
6，返回数据同时返回状态码，和错误信息

跨域问题：
	不同源数据不能共享
	解决办法，jsonp原理，浏览器不拦截使用script标签中的src				属性get请求
		或者自定义中间键，字段，缺啥补啥

drf主要内容：
重新封装了request，解决原生request数据类型方面问题，
添加版本管理，认证，权限管理，限流，序列化器等组件
重新封装原生view试图，形成APIView，再次衍生Genericapiview，genericviewset，甚至针对不同请求细化视图
list-create-retrieve-update-destory-modelview
其他，过滤器、路由、解析器、分页器等
```



### 熟悉Pandas、Numpy、Scikit-learn等数据分析库，了解Tensorflow机器学习库。

# **数据库相关**

### 熟悉MySQL数据库以及原生sql语句，了解MySQL索引原理，事务等。

```
索引结构：聚簇索引（书本，有序。。）、非聚簇索引（字典，hash对映。。
索引的数据结构：二叉树，有序列表，平衡二叉树，b树，b+s

基于b+树实现，效率快
innodb（一体） & mysiam（索引数据分离）
innodb支持行锁，外键，事务，安全性更高，mysiam表锁，全文索引，在数据的查询，删除，插入方面更快(比如删表，innodb按行删，mysiam直接重建)、

b+树，一种树状（类二叉树）解构，将数据按照一定顺寻排列，自动按照索引字段构建树，查询的时候，从最上层开始一层一层向下访问，直到访问得到数据
mysiam非聚簇索引，基于b+树实现，最底层存放的是数据的内存地址
innodb聚簇索引，同样基于b+树实现，最底层存放的是完整的数据体，如果创建著逐渐紫外的索引，那么最底层存放的是主键的值（找到主键值后，再到主键树里面查找d）。


int bigint tinyint float double decimal char varchar text longtext datetime timestamp date time 
float(32bit)\double(64bit)\decimal(128bit):
精度递增，占用内存递增，运算递增
datetime\timestamp: datetime不处理，timestamp处理成为UTC时间

mysql查看某个表的列名
	mysql -uusername -p 输入密码按登录mysql
	show databases; 查看有哪些数据库
	use dbname; 选择数据库
	show tables；查看这个库有哪些表
	desc tablename; 查看某个表的详细信息，包括列名。

数据库：
创建-create    删除-drop    进入数据库-use

数据表：
创建create//删除drop//清空数据delete from-trncate table
修改alter table (...) 加列add//删列drop column//改列数据类型modify column//修改列数据类型、名称change//修改列的默认值alter (列) + set/drop

数据行：
增 insert into (...) values(...)
删 delete from (...) where ...
改 update (...) set ...
查 select ... from (...)

索引未命中：
1，like模糊匹配，并以%开头的
2，类型不一致，name char;  name=123
3，在查询条件字段中使用函数的
4，排序的时候，select *
5，not in, not exist
6，is null(×)   is not null(√)
7，or 中含有未建立索引列
8，联合索引最左原则。。。

事务四大特性：原子性（不可分割），一致性（同进同退），持久性（永久改变），隔离性（两个事务使用的数据不通）

库优化：读写分离，分库分表，定长字段，配置慢日志，事务，命中索引，固定数据放缓存。。。

表优化：建立索引，多条件查询尽量联合索引，外键。。。

主键索引：加速，唯一，非空
唯一索引：加速，唯一
普通索引：加速
```



### 熟悉redis缓存数据库，了解redis持久化机制rdb和aof，主从复制，以及cluster搭建。

```
redisxhttps://www.jianshu.com/p/672bb0ace648

五大数据类型，字符串，哈希，列表，集合，有序集合（分数实现）
redis持久化：通过配置实现
	RDB（redis database）：配置触发快照（save 900 1 900s一个修改就保存）
	AOF(append_only log file)：记录所有变更操作命令

redis主从复制+哨兵：一个master,n个slave，并通过rdb方式复制数据，一旦哨兵发现master炸了，投票一个slave成为新的master

redis-cluster：分布式缓存，balabala。。。


雪崩：redis炸了，大量请求直接指向数据库，导致数据库也炸了
防：限流，主从+哨兵，cluster，持久化
击穿：黑客大量查询id=-1，直接绕过redis直接请求数据库，导致数据库炸了
防：针对这种大量重复请求在缓存设置空返回值
穿透：在某个key失效瞬间，出现大量请求，导致跳过缓存，把数据库炸了
防：监控热点数据延长过期时间
```



# **前端相关**

### 熟悉 HTML标记语言以及常用便签，熟悉CSS样式以及选择器

```
HTML
说几个标签
	html head title style script body
块  h1-h6  div  p table form ol  ul-li
内联 span input img  a br b del 
锚点（内部区块跳转）

CSS
基础选择器：id，class，标签名，通配选择器
组合选择器：基础的组合 
			空格为后代，>为子代
			紧挨为与，逗号为或
			+向下一位，~向下所有
属性·选择器：[属性=val],支持类似正则
伪类选择器：:active :before :after

优先级：!importent > 行内样式 > id > 类 > 标签 > 通配 > 继承

父级塌陷：元素跳出父级标签的范围，可以通过设置父级标签高度（×），添加空白div块，添加overflow属性，以及设置after伪类解决（√）

```



### 熟悉Javascript基础数据解构和语法，以及BOM和DOM对象操作。

```
js数据类型：字符串(string)[查长，分割，切片，索引，大小写转换，截取，去空]，数字(number)，布尔(bool)[!!!Boolean([],{})都是True，区分py]，		null&undefined
对象类型：数组(array)，object，date，math

BOM:
windows.alert() .open() .setInterval()窗口对象
location地址栏对象
localstorage本地永久存储对象
sessionstorage本地会话存放对象


DOM:
document.getElementsByClass("标签名")
document.queryselector() css查找
查找到的标签可以执行再次查孩子，绑定事件，更改属性，操作节点等事件

```



### 熟悉JQuery，Bootstrap等前端开发库，并能结合使用快速开发页面。

### 了解VuE前端开发框架，能够阅读前端代码。

# **Linux****相关**

### 熟悉使用Linux常用命令，能够结合python和shell实现Linux脚本开发。

```
常用命令
ls cd pwd rm touch man echo vim cat mv alias find grep 
head tail scp top sudo ps kill chmod chown tar crontab
```



### 了解基于nginx+uwsgi+django+virtualenv+supervisor的项目部署流程

### 了解常用中间件工具，消息队列RabbitMQ，分布式框架celery

# **其他技能**

### 熟练使用 git/svn等代码管理工具。 

### 拥有回归分析，时序分析，机器学习等相关的统计分析技能。











项目方面：

1，网易云评论爬虫

```
为啥爬：老网抑了，弄点评论里面的鸡汤+练手+闲的没事
难点：逆向获取AES加密（原文，密钥，pi）的key
```

2，间隙后台

```
功能：认证，信息管理，使用记录
----------------------------------------
用户表，客户表，日志表，客户使用详情表，。。。
对数据的操作
增：添加用户，添加客户
	django+钩子验证保存
查：查用户，查使用记录。。
	django orm + drf序列化返回
删：删用户
	orm删除
改：改用户
	orm改

------------------------------------------
难点：首个项目，哪里都难，balabala
不足：小项目有个jb不足
		
```

3，间隙教育在线

```
功能：认证，查看课程，购物车，支付结算
---------------------------------------------------
认证：--用户表
	注册，密码使用MD5+盐加密
	登录，{code:...,data:...},成功uuid4生成token放到			redis
	
课程：--课程分类，课程表，课程详情，课程大纲，价格策略
	针对不同的视图函数，处理方式大同小异，首先orm查询数据库，分别编写序列化器，对数据格式化，返回。
	
购物车：--优惠券，优惠券流水，订单，订单详情
	增post：
		接受前端返回的课程id，价格策略id，校验课id，根据课程id关联到价格策略，校验价id，合法的话，封装成为字典，写入到redis(key=字段+用户id+课程id)。
	查get：
		根据用户id，拼接key = 字段+用户id+*，模糊查询所有的，迭代器返回。
	改put：
		校验id合法性，拼接完整key，redis检查是否存在，更新数据
	查delete：
		校验课程id合法性，redis删除key，done
		
结算：
	增：
		获取前端传回的课程列表，拆分每个课程：1，检查是否存在于reids。 2，找到用户所有合法优惠券。3，将优惠券与课程对映，拼接数据（区分全局优惠券以及课程优惠券）。 4，key=字段2+用户id+课程id，存放到redis。done
	查：
		根据用户id，拼接key，模糊查。。。（同购物车）
	改：
		校验，检查，拼接key，更新（同购物车）

支付：计算最终价格
---------------------------------------------------
难点：
for me技术方面难点不多，本项目最大的难点在于设计表结构方面，最终的设计是经过多次小组讨论推敲，并在实践中一步步完善的，比如，多张表之前的相互约束问题，只靠外键不能很好的解决，经过多此的尝试，最终使用django的contenttype解决。。。

不足：
主要体现在运行效率方面吧，表结构的设计有待优化，所以针对表的操作会有优化空间。

```













# 杂记

字典排序：

```python
ss = {'a': 3, 'c': 2, 'b': 1}
# 按照key进行排序
print(sorted(ss.items()))
# 按照value进行排序
print(sorted(ss.items(), key=lambda x: x[1]))
```

排序方面的扩展

```python
# list.sort()函数默认返回的是从小到大的顺序，
# 参数reverse， key。。。

# 用自定义规则排序
# [333,22,52], 想要输出组成的最大的数，5233322，那么就要排序成[52，333， 22]，想要实现这种效果必须自定义排序规则


# 1，自定义一个排序规则
def mysort(a, b):
    if a + b > b + a:    # 33322 > 22333 ?
		return 1    # 如果认为[a, b]排序后为[a, b],返回任意负数即可
    elif a + b < b + a:    # 33322 < 22333 ?
        return -1	# 如果认为[a, b]排序后为[b, a],返回任意正数即可
    return 0    # 如果认为相等, 返回0

# 2，引入python的支持自定义规则的模块
from functools import cmp_to_key

# 3，使用sort()函数
li = [333, 22, 52]
li.sort(key=cmp_to_key(mysort), reverse=False)  # [22, 333, 52]
```

对字符串方法的一些笔记

```python
#1， isdecimal, isdigit, isnnumeric
# 约束递减，分别为十进制数字， 包含byte类型的数字， 包含中文，罗马式数字，希腊数字类型的数字


num = ['1', '１', 'Ⅷ', '一', b'50']
 
decimal = [i for i in num[:4] if i.isdecimal()]     # 仅单字节、双字节数字，byte数字报错
digital = [i for i in num if i.isdigit()]           # 非汉子
numeric = [i for i in num[:4] if i.isnumeric()]     # byte数字报错 
print(decimal,digital,numeric, sep='\n')
# ['1', '１']
# ['1', '１', b'50']
# ['1', '１', 'Ⅷ', '一']


# 2，有关strip方面的理解
# 以lstrip为例,从头部进行过滤
'aabbccdaaaa'.lstrip('abc')
# 等价于
b = list('aabbccdaaaa')
for i in b:
    if i in ['a', 'b', 'c']:
        b.remove(i)
    else:
        break   # 如果遇到不在过滤的字段中的字符，直接返回
# 同理，对于rstrip, strip，只不过是换了方向而已

# ！！！对于replace，不要把替换的字段进行拆分了
'accacbbacacaac'.replace('ac', '-')
# '-c-bb--a-'
```

