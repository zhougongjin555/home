# windows配置项目文件

- 前言

```bash
	首先观察 Django settings文件夹，发现需要配置的数据库有mysql，和postgresql
	同时观察到数据库的host port等变量存放在系统变量中，通过os.getenv("str", default='str2')的方式获取，但是对于windows来说，这些变量不能像linux or mac那样能够自动的创建（创建方式暂时未知），所以，一种解决方案是使用windows的wsl技术，在windows里面创建一个linux子系统，将项目放置在linux中运行
```

## 一、wsl使用教程

```shell
	wsl是win10 系统自带的一个命令，用来结合windows和linux实现文件和命令互通，
	1，可以在powershell中输入 wsl + linux命令实现使用linux命令方式操作windows文件
	2，相反，对于wsl 中的Ubuntu，可以通过 windows命令.exe 方式运行windows命令
	
	地址栏输入 \\wsl$, 可以打开wsl中ubuntu的文件目录（慎重修改），反之，通过在wsl中 cd /mnt/c 、cd /mnt/d...方式进入windows目录中c盘，d盘...，但是实测，执行效率很慢。
	
	最优运行方式还是项目文件放置到ubuntu目录中。
	
	至此，基本思路完成，开始配置
	
```

### 1， 在微软商店安装 ubuntu和 Windows Terminal（better 终端）

### 2， 安装之后，运行ubuntu，100% 报错

```bash
解决方法，
1，打开设置中开发人员模式，
2，在win终端运行下面命令，打开相关的服务
`dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart`
3，打开设置应用与功能中hyper-v功能，
4，最后检查是否开启cpu虚拟化。
5，如果还报错，命令行运行`wsl --update`更新wsl基本可以解决问题

最后重启电脑
```

### 3，配置ubuntu

```ba
	首次进入 ubuntu 系统会设置访客用户名和密码，由于默认的root管理员密码每次登录都会变化，所以要自己设置，使用命令`sudo passwd`设置管理员密码即可
```

### 4，Windows Terminal中`wsl -l -v`检查 ubuntu 是否成功配置即可

### ![image-20220107095457963](笔记.assets/image-20220107095457963.png)

### 5，外部链接ubuntu（xshell）

https://blog.csdn.net/weixin_43647393/article/details/116013953

**每次打开都还要重新`service ssh start`**

## 二、配置apt源

参考文章https://blog.csdn.net/u010168781/article/details/108230005

### 1、源文件备份

```bash
cp /etc/apt/sources.list /etc/apt/sources.list.bak
```

### 2、检查系统代号

```ba
lsb_release -a
```

### 3 、编辑源列表文件 

```ba
vim /etc/apt/sources.list
```

### 4、将原有的内容注释掉，添加以下内容

```bash
deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse

```

### 5、更新软件列表

```ba
apt-get update
apt-get upgrade
```

### 6、安装oh-my-zsh（选）

```bash
# https://www.jianshu.com/p/37f392355af1
# 查看当前shell
echo $SHELL
# 安装依赖包
sudo apt-get  install zlib1g-dev libbz2-dev libssl-dev libncurses5-dev libsqlite3-dev gcc
# 安装oh-my-zsh
sudo apt install zsh
sh -c "$(curl -fsSL https://gitee.com/shmhlsy/oh-my-zsh-install.sh/raw/master/install.sh)"
# 配置即可

# 字体乱码可使用 powerlines
```

### 7，外部链接mysql

https://blog.csdn.net/sexyluna/article/details/105007828

### 8，外部链接postgresql

https://blog.csdn.net/u011078141/article/details/88665223

## 三、配置项目文件(salmon)

```bash
# 下载项目文件
apt install git -y
cd /opt
git clone https://gitlab.sbuild.cn/zzrr3321/salmon.git

# 安装MySQL      https://blog.csdn.net/weixx3/article/details/80782479
apt install mysql-server mysql-client -y
mysql_secure_installation
mysql -uroot
	# 修改密码
	GRANT ALL PRIVILEGES ON *.* TO root@localhost IDENTIFIED BY "bt254618";
	# 创建p6库
	create database p6;

# 安装postgresql 
apt-get install postgresql postgresql-client -y
# 安装成功后，默认创建超级用户postgres，所以，用此用户测试
sudo -i -u postgres
	psql
	# 进入到postgresql，创建root用户，或者其他名字，但是此处有坑，你linux运行项目的用户名，就是你postgresql的用户名，比如，
	# linux whoami 是zhougongjin，那么要在postgres创建用户zhougongjin，下面例子以root管理员为例
		create role root superuser;  
		exit;
	exit;

# 准备运行项目,首先修改项目的mysql地址为本地
vim /opt/salmon/salmon/settings/env_var.py

TUNA_DB_ENGINE = 'django.db.backends.mysql'
TUNA_DB_NAME = os.getenv('TUNA_DB_NAME', 'p6')
TUNA_DB_USERNAME = os.getenv('TUNA_DB_USERNAME', 'root')
TUNA_DB_PASSWORD = os.getenv('TUNA_DB_PASSWORD', 'bt254618')
TUNA_DB_HOST = os.getenv('TUNA_DB_HOST', 'localhost')
TUNA_DB_PORT = os.getenv('TUNA_DB_PORT', '3306')


# !!!!!!!!!!!!!!!!!!!!
# 最后，设置跳过用户验证，在环境变量中添加测试变量 ，详情见下
# 设置环境变量参考文章
# https://www.cnblogs.com/youyoui/p/10680329.html
su - root 
vim ~/.bashrc 
# 如果使用的是zsh
vim ~/.zshrc

export ENV="true"
export DEBUG="true"
export SKIP_AUTH="true"

source ~/.zshrc


# linux终端运行
python3 manage.py makemigrations
python3 manage.py migrate

python3 manage.py runserver 127.0.0.1:8001  # 此处有坑，wsl与win共享端口，但是win优先级更高，所以8000端口大概率被win占用，改成其他少见端口即可。

```

![image-20220107102725488](笔记.assets/image-20220107102725488.png)

![image-20220107103547818](笔记.assets/image-20220107103547818.png)
























# 杂记

- 本机wsl系统的访客用户名`zhougongjin` , 密码` bt254618`
- 本机wsl系统的管理员用户名`root` , 密码` bt254618`
- 克隆仓库地址`https://gitlab.sbuild.cn/`, 用户名`pengyongkang`，密码` 17816616182.`
- 抽象类和继承类

```bash
# 继承类
 普通的类都是继承类
# 抽象类
 抽象类不能够被实例化，同时抽象类中定义的方法，子类中必须实现
```

- django 相关

```python
# model相关
对于文件类型的字段，不使用 imagefield, 或者 filefield 之类的字段，而是使用自定义的一个类，通过多对多的关系对应上去
枚举类型的字段
class meta:
    adstarct = True  # 设置类为抽象类

# view相关
主要使用drf视图
1，继承自 BaseView（包含了GenericViewSet,
    mixins.CreateModelMixin,
    mixins.RetrieveModelMixin,
    mixins.UpdateModelMixin,
    mixins.DestroyModelMixin,
    mixins.ListModelMixin,）
    五大类介绍： https://www.cnblogs.com/skaarl/p/9487882.html
    

2，get_serializer_class 方法
	主要用来针对不同的请求类型使用对应的序列化器
    def get_serializer_class(self):
        if self.action in ['create', 'update', 'partial_update']:
            return QualityProblemCreateUpdateSerializer
        if self.action == 'reply':
            return QualityProblemReplySerializer
        return super().get_serializer_class()	

3，针对put请求的处理
	@action(methods=['put'], url_name='reply', detail=True, name='reply')    # drf 装饰器，指定处理的请求为put
    def reply(self, request, *args, **kwargs):
        instance = self.get_object()  # get_object() 返回数据对象， get_queryset() 返回数据
        serializer = self.get_serializer_class()(
            data=request.data)
        serializer.is_valid(raise_exception=True)   # 反序列化之前，始终要先实现is_valid()方法, .is_valid()方法使用可选的raise_exception标志，如果存在验证错误将会抛出一个serializers.ValidationError异常。400
        instance = serializer.update(instance, serializer.validated_data)

        return Response(data=self.serializer_class(instance).data, status=HTTP_200_OK)
    
4，create方法解读
	@atomic()
    def create(self, validated_data):
        problems = validated_data.pop('problems', [])   # 保存之前先删除多对多关系字段
        creator_id = self.context["request"].user.id    # 固定方法，拿到request里面的user.id
        updater_id = self.context["request"].user.id

        validated_data.update({     # 给字典更新字段的操作，并非是 drf 的update操作
            "creator_id": creator_id,    
            "updater_id": updater_id,
        })
        instance = super().create(validated_data)  # 继承原生方法中的创建实例方法

        for problem in problems: # problems是关联字段
            try:
                problem_photos = problem.pop('problem_photos', None)  # 删除多对多
                works = problem.pop('works', None)
                obj = QualityProblem.objects.create(**problem)   # 保存实例
                if isinstance(problem_photos, list):   # 判断是否是列表
                    obj.problem_photos.set(problem_photos)   # 保存多对多关系
                if isinstance(works, list):
                    obj.works.set(works)
                instance.problems.add(obj)   # 将实例重新添加到instance上
            except Exception as e:
                raise ValidationError(f'创建失败: {e}
        return instance



5，序列化器
# 如果实例上存在多对多字段，则在模型实例化之前无法设置它们，在这种情况下，实现如下所示
example_relationship = validated_data.pop('example_relationship')
instance = ExampleModel.objects.create(**validated_data)
instance.example_relationship = example_relationship
return instance







# serializers 相关  https://zhuanlan.zhihu.com/p/108055286
主要是使用的自定义的serializers实现对数据进行格式化保存和输出
serializers 初始化的一些属性：
1，required = True # 代表可以接受None空值
2，partial = True # 代表可以局部更新
3，many = True # 代表可 以接受列表或者查询集queryset作为初始数据
4，context = {字典} # 可以接受额外的字段进行序列化


serializers 相关方法：
1, def validate_title(self, value):
    '''验证单个字段'''
        pass
2, def validate(self, data):
   '''验证多个字段'''
		pass

   @atomic()
3, def create(self, data):
   '''保存'''
		pass
		super().create(data)	
    
    
    
4, def update(self, data):
    '''更新'''
		pass   
5, def to_representation(self, instance):
    '''重写原生序列化输出的方式，可以自定义序列化以及增减字段操作'''
      return QualityProblemSerializer(instance).data 
6, def to_internal_value(self, instance):
    '''重写原生反序列化输出的方式'''
      return QualityProblemSerializer(instance).data 

class meta:
    model = Account
    fields = '__all__'      # 取所有字段
    # exclude = ('name', )  # 排除哪些字段
    # read_only_fields = ('str', )  # 规定只读字段
    extra_kwargs = {'password': {'write_only': True}}  # 给字段规定额外参数
    
   
serializers 相关api：
0, .data() # 最原始获取数据方法
1, .is_valid() # 判断是否通过校验， raise_exceptions=TRUE会在检验未通过的时候抛出异常
2, .errors() # 生成的错误消息的字典
3, .instance() # 初始化对象或者查询集传递给序列化实例时，可以通过.instance访问。如果没有传递初始化对象，那么.instance属性将是None。
4, .initial_data() # 数据传递给序列化器实例时，未修改的数据可以通过.initial_data获取。如果没有传递data关键字参数，那么.initial_data属性就不存在
5, .validated_data() # 验证后的数据
6, .save() # 将验证的数据保留到对象实例中

```

- 状态码

```bash
返回状态码和对应的提示信息
100: 已经接受部分请求
200: 请求成功
201: 请求成功，已经新建了资源
202: 请求成功，但是尚未处理，正在排队
204: 请求成功，但是没有内容返回
301: 永久重定向
302: 临时重定向
304: 没有修改
400: 客户端请求错误
401: 没有权限
403: 没有认证，禁止请求
404: 请求未找到
500: 服务器内部错误
```



# 知识点扩充

## 1，django配置文件之lazysetting对象

```bash
# 看项目settings配置文件，惊奇发现，没有用原生的写死的settings.py，而是使用的LazySetting对象来获取项目的配置
https://www.cnblogs.com/time-read/p/10580378.html
https://zhuanlan.zhihu.com/p/150778023
# 好处：
LazySetting顾名思义，就是延迟获取配置内容。比如，我们定义了一个对象A，并对其添加了一些属性，对A初始化时，我们将A的属性的值设置为空，当我们要访问A其中的一个属性时，此时属性的值为空，我们才加载属性的值，并将空值设置为对应的值，返回属性值，下次获取属性值时，属性值不为空，直接返回属性值。

# 为什么用？
django项目在初始化的时候， 通过LazySetting，我们就可以在django获取某个配置的值之前，将配置的值先自定义为某个值，django再去获取该配置的值的时候，配置已经有了值，直接返回该配置的值。

# 项目涉及
	首先发现，配置完成项目，首次运行之后，虽然能够正常的进入web网页端，但是返回信息 {"error": "获取用户登录认证信息失败"}  ，出现这种问题，先从中间件方面考察
	MIDDLEWARE = [
    # 安全中间件
    'django.middleware.security.SecurityMiddleware',
    # 默认处理Session 存储的中间件
    # 'django.contrib.sessions.middleware.SessionMiddleware',
    # 重定向，访问控制
    'django.middleware.common.CommonMiddleware',
    # 跨站点请求伪造的保护
    # 'django.middleware.csrf.CsrfViewMiddleware',
    # 用户认证，向每个接收到的HttpRequest对象添加user属性，表示当前登录的用户，依赖于 SessionMiddleware
    # 'django.contrib.auth.middleware.AuthenticationMiddleware',
    # 常用消息中间件，如flash message, 依赖于 SessionMiddleware
    # 'django.contrib.messages.middleware.MessageMiddleware',
    # 点击劫持，安全中间件
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    "salmon_app.middlewares.jwt_user_middleware.JWTUserMiddleware",
    "salmon_app.middlewares.get_headers_middleware.GetHeadersMiddleware",
    # captures the current request and user in thread local storage.
    'crum.CurrentRequestUserMiddleware',]
发现除了，自带的中间件之外，自定义了三个劫持中间件，进入首个中间件后观察到，
  ...
                      if not cur_user:
                        return JsonResponse(
                            {"error": f"{settings.PROJECT_CODE}项目下暂无用户"},
                            status=status.HTTP_401_UNAUTHORIZED,
                            json_dumps_params={'ensure_ascii': False}
                        )
  ...
  
  定位到问题所在，没有携带用户信息，往上再看，发现定义了绕开的方式，
```

## 2，postgresql学习

```bash
# 教程参考 http://www.postgres.cn/docs/12/index.html

# 常用命令参考  https://blog.csdn.net/u010856284/article/details/70142810
\du 查看所有的用户
\l  查看所有的数据库
\c + 数据库  进入到数据库中     eg: \c postgres  
\d  \dt  查看数据库中的表格
\di  查看索引信息


# 数据类型    https://www.runoob.com/postgresql/postgresql-data-type.html
数值类型、货币类型、字符类型、日期时间类型、布尔类型、枚举类型、几何类型（点线面）、网络地址类型、位串类型、文本搜索类型、uuid类型、XML类型、JSON类型、数组类型、复合类型、范围类型、对象标识符类型、伪类型、
```





## 3，pytest学习



## 4，graphql学习

```python
# graphql python相关库  graphene    
# 基础配置教程https://www.howtographql.com/graphql-python/0-introduction/

# 类方法使用
1，创建模型对象
class LinkType(DjangoObjectType):
    '''创建类，继承DjangoObjectType方法，实现graphql的类'''
    class Meta:
        model = Link



2，创建query类，并注册在主schema文件中，实现数据的返回
class Query(graphene.ObjectType):
    '''创建query类，实现对数据进行序列化返回，包括数据库所有字段验证，过滤等相关操作'''
    users = graphene.List(UserType)

    def resolve_users(self, info):
        '''对数据库的序列化操作方法'''
        return get_user_model().objects.all()


    
3，创建createxxx  &&   mutation类，并注册，实现对数据的保存
class CreateLink(graphene.Mutation):
    '''指定类里面的所有字段'''
    id = graphene.Int()
    url = graphene.String()
    description = graphene.String()
    posted_by = graphene.Field(UserType)

    class Arguments:
        '''定义可以发送到服务器的字段'''
        url = graphene.String()
        description = graphene.String()

    def mutate(self, info, url, description):
        '''对数据的处理和保存, 主执行的函数'''
        user = info.context.user or None

        link = Link(url=url, description=description, posted_by=user)
        link.save()

        return CreateLink(
            id=link.id,
            url=link.url,
            description=link.description,
            posted_by=link.posted_by,
        )
    
    
class Mutation(graphene.ObjectType):
    create_link = CreateLink.Field()
```



## 5，redis

```bash
# redis优秀介绍文章
https://juejin.cn/post/7049148028875178020
```



