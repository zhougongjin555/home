# 数据结构

```
# https://zhuanlan.zhihu.com/p/138523723

逻辑结构
	- 线性
		- 栈
		- 队列
		- 数组
		- 链表
	- 非线性
		- 散列表
		- 树
		- 堆
		- 图
存储结构
	- 顺势存储
	- 链式存储
	- 索引存储
	- 散列存储
	
	
```

### 数组、列表

![img](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2Fimg_convert%2F1146d4ecef61d4d4cbddcf7e602b915a.png&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1641817548&t=1cd24aa9118c0f84511e17c5c5ea0917)

```
数组是长度的，并且数组内部元素类型统一

python对数组衍生的结构是列表，可变长，并且内部元素是鸭子类型
```

### 栈，队列

![img](https://pic3.zhimg.com/v2-42561c6733c8bb043eb618ca2b6aff4e_r.jpg)

![img](https://pic1.zhimg.com/v2-ae730139b71f9c3ebb199dd5a588e07c.jpg)

python四种类型的队列

`Queue`：FIFO 即 first in first out 先进先出

```python
queue.qsize()  获取队列的数据个数
queue.put(item, block=True, timeout)  # 放入数据，数据已满是否阻塞？阻塞时间？，过了时间就报错queue.full
queue.put_nowait()   ===    queue.put(item, block=False)
queue.get(block=True, timeout)
queue.get_nowait()   ===    queue.get(block=False)
queue.full()   queue.empty()  # 是否满？空？
queue.task_done()   # 告知队列此任务已经完成
queue.join()   # 阻塞进程，直至所有任务完成，结合task_done使用



a = Queue(maxsize=5)

# 插入
try:
    for i in range(6):
        a.put(i, block=True, timeout=1)  # 如果无法插入，阻塞住1s，报错full
        print(f'插入{i}, 队列数据{a.queue}, 队列大小{a.qsize()}')
except Exception as e:
    print(str(e))

# 取出
try:
    for i in range(6):
        b = a.get(block=True, timeout=2)
        a.task_done()  # 告知队列此任务已经执行完成，结合join()使用，所有都完成，则join不再阻塞
        print(f'取出{b}, 队列数据{a.queue}, 队列大小{a.qsize()}')
except Exception as e:
    print(str(e))

a.join()   # 阻塞进程，直至所有任务完成，一般结合task_done使用

print('done')


插入0, 队列数据deque([0]), 队列大小1
插入1, 队列数据deque([0, 1]), 队列大小2
插入2, 队列数据deque([0, 1, 2]), 队列大小3
插入3, 队列数据deque([0, 1, 2, 3]), 队列大小4
插入4, 队列数据deque([0, 1, 2, 3, 4]), 队列大小5

取出0, 队列数据deque([1, 2, 3, 4]), 队列大小4
取出1, 队列数据deque([2, 3, 4]), 队列大小3
取出2, 队列数据deque([3, 4]), 队列大小2
取出3, 队列数据deque([4]), 队列大小1
取出4, 队列数据deque([]), 队列大小0

done

```



`LifoQueue`：LIFO 即 last in first out 后进先出 **栈**

```python
from queue import LifoQueue
a = LifoQueue(maxsize=5)
...


插入0, 队列数据[0], 队列大小1
插入1, 队列数据[0, 1], 队列大小2
插入2, 队列数据[0, 1, 2], 队列大小3
插入3, 队列数据[0, 1, 2, 3], 队列大小4
插入4, 队列数据[0, 1, 2, 3, 4], 队列大小5

取出4, 队列数据[0, 1, 2, 3], 队列大小4
取出3, 队列数据[0, 1, 2], 队列大小3
取出2, 队列数据[0, 1], 队列大小2
取出1, 队列数据[0], 队列大小1
取出0, 队列数据[], 队列大小0

done
```



`PriorityQueue`：优先队列，级别越低，越优先

```python
# 自定义优先级别数字，类似redis的有序集合，你说分数多少就是多少，你说多优先就多优先

from queue import PriorityQueue


def priority_queue(put_data):
    """
    Priority，优先队列，级别越低，越优先
    :param put_data: 放入的数据，列表或元组类型
    :return:
    """
    assert isinstance(put_data, (list, tuple)), '请传入列表或元组类型的put_data'

    # maxsize为队列数据上限，小于或等于0则不限制，当容器数量大于这个数则阻塞，直到队列中的数据被消掉
    q = PriorityQueue(maxsize=0)

    # 依次写入队列数据
    for each in put_data:
        print(f'添加{each}到队列，优先级别为：{each[0]}')
        q.put(each)

    print(f'当前队列所有数据：{q.queue}')

    # 逐次取出所有数据，按优先级获取
    while not q.empty():
        print(f'取出：{q.get()}')

    print(f'当前队列所有数据：{q.queue}')


if __name__ == '__main__':
    priority_queue(put_data=[(3, 'value1'), (1, 'value2'), (2, 'value3')])
    
    
    
添加(3, 'value1')到队列，优先级别为：3
添加(1, 'value2')到队列，优先级别为：1
添加(2, 'value3')到队列，优先级别为：2
当前队列所有数据：[(1, 'value2'), (3, 'value1'), (2, 'value3')]
取出：(1, 'value2')
取出：(2, 'value3')
取出：(3, 'value1')
当前队列所有数据：[]


```



`deque`：双端队列

```python
from collections import deque
a = deque(List)

a.append()//appendleft()
a.pop()//popleft()
a.extend()//extendleft()
a..remove()
a.clear()
a.insert()
a.index()
a.reverse()
a.rotate()  # 旋转
```

### 链表

```python
```





### 树，堆

```python
```



### 图

```python
```



# 算法

### 查找

- 顺序查找

  ```python
  def linear_search(li, target):
      for index,val in enumerate(li):
          if val == target:
              return index
      return -1
  ```

- 二分查找

  ```python
  def binary_search(li, target):
      low = 0
      high = len(li) - 1
      # 候选区有值
      while low <= high:
          mid = (low + high) >> 1
          if mid == target:
              return mid
          elif mid < target:
              low = mid + 1
          else:
              high = mid - 1
      else:  # 指定找不到的情况
      	return -1
  ```

  

### 排序

垃圾三人组（n^2）

- 冒泡排序（n^2）

  ```python
  def bubble_sort(li):
      for i in range(len(li)):  # 第i趟
          exchange = False # 加一个标识来确定该趟是否进行过排序变动
          for j in range(len(li) - 1 - i):  # 指向无序区的指针
              if li[j] > li[j+1]: # 指针指向的值，和指针上面的值作比较
                  li[j], li[j+1] = li[j+1], li[j]
              	exchange = True # 如果交换了元素，即发生了变动，那么变更为True
          if not exchage:  # 如果False, NOT FALSE = True，直接返回，减少趟数
              return li
      return li
              
  ```

- 选择排序（n^2）

  ```python
  # 思想，每次选择出来一个最小的数字出来
  # 最简单的写法
  def select_sort(li):   # 总复杂度为o(n^2)
      li_new = []
      for i in range(len(li)):   # o(n)
          min_val = min(li)      # o(n)
          li_new.append(min_val)    
          li.remove(min_val)     # o(n)
      return li_new
  
  
  # 进阶写法
  # 思想，每次选择最小的值放到列表最前端，共选择n-1趟，类似冒泡
  def select_sort(li):
      for i in range(len(li) - 1):
          min_loc = i
          for j in range(i, len(li)):
              if li[min_loc] > li[j]:
              	min_loc = j
              li[min_loc], li[j] = li[j], li[min_loc]
      return li
  ```

- 插入排序（n^2）

  ```python
  # 思想，每次从列表拿出来一个元素，插入到另一个有序列表的合适位置
  def insert_sort(li):
      for i in range(1, len(li)): # i代表摸到的元素
          j = i - 1 # j代表手中牌的下标
          while j >= 0 and li[j] > li[i]: # 满足指针不能指向负数，同时摸到元素小于有序区的元素
              li[j+1] = li[j] # 有序区最后元素往后挪一格
              j -= 1  # 指针向前指
          li[j+1] = li[i]  # 如果摸到的牌比有序区都大，那么直接插到有序区最后
  ```

- 希尔排序

  ```python
  ```

  

牛逼三人组（nlogn）

- 快速排序（nlogn）

  ```python
  # 思想：取第一个元素p，归位（实现左边元素都小于p,右边元素都大于p），递归
  def partition(li, left, right):
      tmp = li[left]
      while left < right:
          while left < right and li[right] >= tmp: # 从左边找小于tmp的值
              right -= 1   # 本次未找到，左边指针前移一位
          li[left] = li[right]  # 找到后，把小于tmp的值放到左边指针的空位置
          while left < right and li[left] <= tmp: # 从右边找大于tmp的值
              left += 1   # 本次未找到，左边指针后移一位
          li[right] = li[left]    # 找到后，把大于tmp的值放到右边指针的空位置
      li[left] = tmp  # 如果left = right，跳出循环，把tmp归位
      return left  # 返回中间的位置
          
  def quick_sort(li):   # 直接修改了原有列表，不用返回结果
      left = 0
      right = len(li) - 1
      if left < right:
          mid = partition(li, left, right)
          quick_sort(li, left, mid-1)
          quick_sort(li, mid+1, right)
  # 最坏情况[9,8,7,6,5,4,3,2,1] ,此时时间复杂度n^2
  # 并且递归可能出现爆栈问题
  
  # 另一种实现方式
  def quick_sort(li):
      if len(li) < 2:
          return li
      else:
          tmp = li[0]  # 随便取第一个值
          greater = [i for i in li[1:] if i > tmp]  # 所有大于首位的值
          less = [j for j in li[1:] if j <= tmp]  # 所有小于首位的值
          li = quick_sort(less) + [tmp] + quick_sort(greater)  # 递归 重组列表
          return li
  ```

- 堆排序（nlogn）

  ```python
  # 堆：完全二叉树，并且满足根节点大于两个孩子节点的值（大根堆）//小于两个孩子节点的值（小根堆）
  def shit(li, low, high):
      i = low  # i最开始指向根节点
      j = 2 * i + 1  # j是左孩子   2*i+2是右孩子
      tmp = li[low]
      while j <= high:
          if j + 1 < high and li[j + 1] > li[j]:
              j = j + 1  # 如果右孩子更大，j指向右孩子
          if li[j] > tmp:
              li[i] = li[j]
              i = j  # 向下一层
              j = 2 * i + 1
          else:
              break
      else:
          li[i] = tmp
      return li
  
  
  @timer
  def heap_sort(li):
      n = len(li)
      for i in range((n - 2) // 2, -1, -1):
          shit(li, i, n - 1)
      for i in range(n - 1, -1, -1):
          li[0], li[i] = li[i], li[0]
          shit(li, 0, i - 1)
          
          
  # python内置模块实现堆排序
  import heapq
  def heapq_moudle(li, n): # 前n个元素
      heapq.heapify(li)   # 将列表构建成堆的结构 
      for i in range(n):
          print(heapq.heappop(li), end=',')   # 每次弹出最小的一个元素
      print(heapq.nlargest(3, li))   # 获得堆的最大三个数
      print(heapq.nsmallest(3, li))   # 获得堆的最小三个数
  ```

- 归并排序（nlogn）

  ![屏幕截图 2021-12-10 173734](E:\home\复习\assets\屏幕截图 2021-12-10 173734.png)

  ```python
  # 规并：把两个有序列表合成一个有序列表成为一次归并
  def merge(li, low, mid, high):
      i = low
      j = mid + 1
      ltmp = []
      while i <= mid and j <= high:
          if li[i] < li[j]:
              ltmp.append(li[i])
              i += 1
          else:
              ltmp.append(li[j])
              j += 1
      while i <= mid:
          ltmp.append(li[i])
          i += 1
      while j <= high:
          ltmp.append(li[j])
          j += 1
      li[low: high + 1] = ltmp
  
  
  def merge_sort(li, low, high):
      if low < high:
          mid = (low + high) // 2
          merge_sort(li, low, mid)
          merge_sort(li, mid + 1, high)
          print(li[low: high+1], low, mid, high)
          merge(li, low, mid, high)
         
  ```

大佬三人组（n）

- 基数排序

  ```python
  ```

  

- 计数排序

  ```python
  ```

  

- 桶排序

  ```python
  
  ```



### 字符串匹配算法

- 朴素

  ```python
  
  ```

- RK

  ```python
  
  ```

- BM

  ```python
  
  ```

- KMP

  ```python
  
  ```

- Tire

  ```python
  
  ```

- AC自动组

  ```python
  
  ```

- 后缀数组

  ```python
  ```


### 五大常用算法

- 递归与分治

  ```
  递归是基础，延伸出  ‘分而治之’  和  ‘动态规划’
  
  
  分治基础：
  子问题 '独立同分布'，易解决，总问题是子问题的和
  ```

  

- 动态规划

  ```
  重点是   状态转移方程    和     处理边界条件
  ```

  

- 贪心算法

- 回溯法

- 分支限界法

# 杂记

- 斐波那契数列

  ```python
  def fibnacci(n):   # [0,1,1,2,3,5,8...]
      fib = [0, 1]
      if n < 3:
          return fib[:n]
      else:
          for i in range(n-2):
              num = fib[-1] + fib[-2]
              fib.append(num)
      return fib
  ```

- 滑动窗口算法

  ```python
  # LT.2
  def maxslidingwindow(li, k):
      from collections import deque
      d = deque()   # 保存的是元素的索引，并非值
      outp = []
      
      for index,val in enumerate(li):
          if d and li[d[-1]] < val:  # 最后一个元素对比新拿到的值，如果小于，那么弹出队列
              d.pop()   # 弹出双向队列
          d.append(index)   # 无论如何，新的元素的索引都会插入到双向队列中去
          if d[0] == index - k:  # 如果索引 4 超出了 k=3 的范围，那么找索引（4-3=1）是否在双向队列中，如果在，删除
              d.popleft()
          if index >= k - 1:   # 长度达标，那么返回双向队列的首个元素，一定是最大的值
              outp.append(li[d[0]])
      return outp
  
  # LT.209
  def maxslidingwindow(nums, target):
      d = collections.deque()
      lenp = 0 if sum(nums) < target else len(nums)
      if sum(nums) <= target:
          return lenp
      for num in nums:
          d.append(num)
          while sum(d) >= target:
              if len(d) < lenp:
                  lenp = len(d)
              d.popleft()
      return lenp
  ```
  
- 双指针算法

  ```python
      # 三数之和问题
      
      def threeSum(self, nums: List[int]) -> List[List[int]]:
          if len(nums) < 3:
              return []
          a = []
          nums.sort()    # 先排序方便遍历
          for i in range(len(nums) - 2):
              if nums[i] == nums[i-1] and i > 0:
                  continue
              low = i + 1   # 头指针指向首个元素
              high = len(nums) - 1    # 尾指针指向尾部元素2
              while low < high:
                  if nums[i] + nums[low] + nums[high] < 0:
                      low += 1
                  elif nums[i] + nums[low] + nums[high] > 0:
                      high -= 1
                  else:
                      a.append([nums[i], nums[low], nums[high]])
                      while low < high and nums[low] == nums[low+1]:    # 如果出现了重复元素，跳过
                          low += 1
                      while low < high and nums[high] == nums[high-1]:   # 如果出现了重复元素，跳过
                          high -= 1
                      low += 1      # 数据添加完毕，还要继续遍历，条件不能忘
                      high -= 1
          return a
  
  ```

- 动态规划问题

  ```python
  # 动态规划问题核心是找到，递归的点
  
  LT.53   
  def maxSubArray(self, nums: List[int]) -> int:
      maxsum = temp = nums[0]
      for i in range(1, len(nums)):
          temp = max(temp + nums[i], nums[i])
          maxsum = max(temp, maxsum)
      return maxsum
  
  
  ```

- 自定义排序算法 + 优秀的对比方式

  ```python
  class Solution:
      from functools import cmp_to_key
      def largestNumber(self, nums: List[int]) -> str:
          if len(nums) == 1:
              return str(nums[0])
          nums = [str(i) for i in nums]
          nums.sort(key=cmp_to_key(self.mysort), reverse=True)
          return str(int(''.join(nums)))
  
      def mysort(self, a, b):
          if a + b > b + a:
              return 1
          elif a + b < b + a:
              return -1
          return 0
  ```

- 贪心算法

  ```python
  # LC.55 跳跃问题
  class Solution:
      def canJump(self, nums: List[int]) -> bool:
          # 动态规划算法
          # n = len(nums)
          # dp = [0] * n
          # dp[0] = nums[0]
          # for i in range(1, n):
          #     if dp[i-1] >= i:
          #         dp[i] = max(dp[i-1], nums[i]+i)
          #     else:
          #         dp[i] = dp[i-1]
          # return dp[n-1] >= n-1
  
          # 贪心算法,每次找到最优的结果,局部最优和==全局最优
          begin, end = 0, 0
          while 1:
              next_end = end
              for i in range(begin, min(end + 1, len(nums))):
                  next_end = max(next_end, i + nums[i])
              if next_end == end:
                  break
              begin, end = end + 1, next_end
          return end >= len(nums) - 1
  
  ```

  